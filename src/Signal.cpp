#include "Signal.h"

void Signal::init()
{
    set_signal_masks();
    set_signal_fds();
}

void Signal::set_signal_fds()
{
    // Create epoll instance
    if ((_epoll_fd = epoll_create(MAX_EPOLL_EVENTS)) == -1) {
        std::cout << "Failed to create epoll instance\n";
        std::perror("epoll_create");
        std::exit(-1);
    }
    
    // Create signalfd and register to epoll
    if ((_signal_fd = signalfd(-1, &_signal_set, 0)) == -1) {
        std::cout << "Failed to create a signalfd\n";
        std::perror("signalfd");
        std::exit(-1);
    }
    
    struct epoll_event events[MAX_EPOLL_EVENTS];

    struct epoll_event ev = {0};
    ev.events = EPOLLIN;
    ev.data.fd = _signal_fd;

    if (epoll_ctl(_epoll_fd, EPOLL_CTL_ADD, _signal_fd, &ev) == -1) {
        std::cout << "Failed to register signalfd to epoll\n";
        std::perror("signalfd");
        std::exit(-1);
    }

}

void Signal::set_signal_masks()
{
    if (sigemptyset(&_signal_set) == -1) {
        std::cout << "Error filling w/ empty set\n";
        std::perror("sigemptyset");
        std::exit(-1);
    }

    if (sigaddset(&_signal_set, SIGTERM) == -1) {
        std::cout << "Failed to add SIGTERM to signal set\n";
        std::perror("sigaddset");
        std::exit(-1);
    }

    if (sigaddset(&_signal_set, SIGINT) == -1) {
        std::cout << "Failed to add SIGINT to signal set\n";
        std::perror("sigaddset");
        std::exit(-1);
    }

    if (sigprocmask(SIG_BLOCK, &_signal_set, 0) == -1) {
        std::cout << "Failed to block signal set\n";
        std::perror("sigprocmask");
        std::exit(-1);
    }

    // TODO: Update this w/ Log statements
    std::cout << "Ready to catch SIGTERM and SIGINT\n";
}

void Signal::main_loop()
{
    /*
     * I want the Signal class to handle signals generated by myself or
     * any other thread such as the potential CommHandler
     * 
     * The Signal class will call the kill flag and upon seeing this,
     * the VehicleManager will then execute a "cleanup" sequence

     * Is this the best way to do it? Probably not, but it's okay
     */

    while (!_kill_flag.get_kill()) {
        poll_events();
    }
}

void Signal::poll_events()
{
    struct epoll_event events[MAX_EPOLL_EVENTS];
    int num_fds = epoll_wait(_epoll_fd, events, MAX_EPOLL_EVENTS, -1);

    if (num_fds == -1) {
        std::cout << "Failed to wait\n";
        std::perror("epoll_wait");
        std::exit(-1);
    }

    evaluate_epoll_events(num_fds, events);
}

void Signal::evaluate_epoll_events(int fds, struct epoll_event* events)
{
    int idx = 0;
    while (idx < fds) {
        if (events[idx].data.fd == _signal_fd) {
            process_signal_fd();  
        }

        else {
            std::cout << "Uknown file descriptor\n";
        }
        ++idx;
    }
}

void Signal::process_signal_fd()
{
    struct signalfd_siginfo sig_info = {0};
    int read_count = read(_signal_fd, &sig_info, sizeof(sig_info));      

    if (read_count != sizeof(sig_info)) {
        std::cout << "Read count not expected!\n";
    }

    switch (sig_info.ssi_signo) {
        case SIGINT:
            std::cout << "Received SIGINT!\n";
            shutdown_sequence();
            break;

        case SIGTERM:
            std::cout << "Received SIGTERM\n";
            shutdown_sequence();
            break;

        default:
            std::cout << "Uknown signal flag received " << sig_info.ssi_signo
                      << "\n";

            break;
    }
}

void Signal::shutdown_sequence()
{
    _logger.flush_log();
    _kill_flag.kill();
}



void* signal_main_loop(void* obj)
{
    Signal* sig = (Signal*) obj;
    sig->main_loop();

    return nullptr;
}

